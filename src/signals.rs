//! Signal type definitions for the aggregate-only architecture
//!
//! Phase 1: Type definitions only (no detection logic)

/// Signal types matching token_signals.signal_type column
///
/// SQL reference: `/sql/03_token_signals.sql`
///
/// These signal types are defined in the system specification:
/// - BREAKOUT: Sudden spike in volume or price movement
/// - FOCUSED: Concentrated buying from small number of wallets
/// - SURGE: Sustained high volume over time window
/// - BOT_DROPOFF: Sudden decrease in bot trading activity
/// - DCA_CONVICTION: Jupiter DCA BUYs overlap with spot BUYs (accumulation signal)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum SignalType {
    Breakout,
    Focused,
    Surge,
    BotDropoff,
    DcaConviction,
}

impl SignalType {
    /// Convert signal type to string representation for database
    ///
    /// Returns uppercase string matching SQL enum values
    pub fn as_str(&self) -> &'static str {
        match self {
            SignalType::Breakout => "BREAKOUT",
            SignalType::Focused => "FOCUSED",
            SignalType::Surge => "SURGE",
            SignalType::BotDropoff => "BOT_DROPOFF",
            SignalType::DcaConviction => "DCA_CONVICTION",
        }
    }
}

/// Token signal event matching token_signals table schema
///
/// SQL reference: `/sql/03_token_signals.sql`
///
/// All field names are EXACT matches to SQL column names.
///
/// Signals are append-only events written to the database when
/// certain conditions are detected in the aggregate metrics.
#[derive(Debug, Clone)]
pub struct TokenSignal {
    // Note: 'id' field is auto-generated by SQLite (AUTOINCREMENT)
    // and not included in this struct for INSERT operations

    /// Token mint address
    pub mint: String,

    /// Type of signal detected
    pub signal_type: SignalType,

    /// Time window in seconds over which signal was detected
    /// Common values: 60, 300, 900
    pub window_seconds: i32,

    /// Signal severity level (1-5, higher = more important)
    /// Default: 1
    pub severity: i32,

    /// Optional numeric score for signal strength
    pub score: Option<f64>,

    /// Optional JSON string with additional signal details
    pub details_json: Option<String>,

    /// Unix timestamp when signal was created
    pub created_at: i64,

    // Note: sent_to_discord and seen_in_terminal are set by downstream
    // consumers and not included in this struct (they default to 0 in SQL)
}

impl TokenSignal {
    /// Create a new signal with basic fields
    pub fn new(
        mint: String,
        signal_type: SignalType,
        window_seconds: i32,
        created_at: i64,
    ) -> Self {
        Self {
            mint,
            signal_type,
            window_seconds,
            severity: 1, // Default severity
            score: None,
            details_json: None,
            created_at,
        }
    }

    /// Set signal severity (1-5, higher = more important)
    pub fn with_severity(mut self, severity: i32) -> Self {
        self.severity = severity.clamp(1, 5);
        self
    }

    /// Set signal score
    pub fn with_score(mut self, score: f64) -> Self {
        self.score = Some(score);
        self
    }

    /// Set signal details as JSON string
    pub fn with_details(mut self, details_json: String) -> Self {
        self.details_json = Some(details_json);
        self
    }
}

// TODO: Phase 3-C - Add helper methods for JSON serialization
// - fn to_json(&self) -> String - Serialize entire signal to JSON for logging
// - fn from_json(json: &str) -> Result<Self> - Deserialize from JSON
